// class AILevel1
//
// Author: Ovietobore Oghre 7793149
//
// REMARKS: performs the operations of a computer player
//
//-----------------------------------------
public class AILevel1 implements ChessPlayer{
  
  public AILevel1(){
  
  }
  
  //------------------------------------------------------
  // makeMove
  //
  // PURPOSE: to play a move for the AI on easy
  // PARAMETERS: a ChessDisplay
  // Returns: none
  //------------------------------------------------------
  public void makeMove(ChessDisplay d, int rowInit, int colInit, int rowFinal, int colFinal){
    //if(level==1){      
    Random rand = new Random();
    int row1 = rand.nextInt(8);
    int col1 = rand.nextInt(8);
    int row2 = rand.nextInt(8);
    int col2 = rand.nextInt(8);
    
    while( !isValidAI(d.getBoard(), row1, col1, row2, col2)){ //loop until a valid move is made randomly
      row1 = rand.nextInt(8);
      col1 = rand.nextInt(8);
      row2 = rand.nextInt(8);
      col2 = rand.nextInt(8);
    }
    d.summarizeMove(row1, col1, row2, col2);
    if(!(d.getBoard()[row1][col1] instanceof Pawn)|| !(((Pawn)d.getBoard()[row1][col1]).checkForPromotion(d.getBoard(), row1, col1, row2, col2)))
    {
      d.getBoard()[row2][col2]=d.getBoard()[row1][col1];
      d.getBoard()[row1][col1]=null;
      
    }
    d.copyToExtraBoard();
    d.displayBoard();
  }
  
  
  
  //------------------------------------------------------
  // isValidAi
  //
  // PURPOSE: to internally ensure that the AIs move is valid
  // PARAMETERS:
  // 1) 4 integers rowInit, colInit, rowFinal and colFinal representing the begisnning position of the piece
  //     and the end position of the piece
  // 2) a 2 dimensional array of pieces
  // Returns: returns true if the proposed move is legal or false if it is illegal
  //-----------------------------------------------------
  private boolean isValidAI(Piece [][] board, int rowInit, int colInit, int rowFinal, int colFinal ){
    boolean result=false;
    if((rowInit != rowFinal || colInit!=colFinal) && board[rowInit][colInit] != null &&
       board[rowInit][colInit].getTeam()==false){ //a piece cannot stay on the ssame place
      //initial square must contain a computers piece
      //PAWN 
      if(board[rowInit][colInit] instanceof Pawn)
      {
        result=((Pawn)board[rowInit][colInit]).isValid(board, rowInit, colInit, rowFinal, colFinal);
        
      }
      
      //QUEEN
      else if(board[rowInit][colInit] instanceof Queen)//queen
      {
        result = ((Queen)board[rowInit][colInit]).isValid(board, rowInit, colInit, rowFinal, colFinal);
      }
      //ROOK
      else if(board[rowInit][colInit] instanceof Rook )//rook
      {
        result=((Rook)board[rowInit][colInit]).isValid(board, rowInit, colInit, rowFinal, colFinal);
      }
      
      
      else if(board[rowInit][colInit] instanceof Knight)//knight
      {
        result=((Knight)board[rowInit][colInit]).isValid(board, rowInit, colInit, rowFinal, colFinal);
        
      }
      else if(board[rowInit][colInit] instanceof Bishop)//bishop
      {
        result=((Bishop)board[rowInit][colInit]).isValid(board, rowInit, colInit, rowFinal, colFinal);
      }
      else if(board[rowInit][colInit] instanceof King)//king
      {
        result=((King)board[rowInit][colInit]).isValid(board, rowInit, colInit, rowFinal, colFinal);
      }
    }
    return result;
  }
  
  
}

}